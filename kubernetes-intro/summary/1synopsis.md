# Kuber arch
Про архитектуру и компоненты можно почитать в официальной документации https://kubernetes.io/ru/docs/concepts/overview/components/
### Вкратце.

#### Control plane:
### kube-apiserver
Сервер API — компонент Kubernetes панели управления, который представляет API Kubernetes. API-сервер — это клиентская часть панели управления Kubernetes

### etcd
Распределённое и высоконадёжное хранилище данных в формате "ключ-значение", которое используется как основное хранилище всех данных кластера в Kubernetes.

### kube-scheduler
Компонент плоскости управления, который отслеживает созданные поды без привязанного узла и выбирает узел, на котором они должны работать.

* Учет имеющихся ресурсов
* Учет требований к ресурсам
* Учет ограничений по ресурсам (affinity, anti-affinity)
* Решение где запустить контейнеры (на основе ограничений и требований)


### kube-controller-manager
Компонент Control Plane запускает процессы контроллера.  
Каждый контроллер в свою очередь представляет собой отдельный процесс, и для упрощения все такие процессы скомпилированы в один двоичный файл и выполняются в одном процессе.
Эти контроллеры включают:
* Контроллер узла (Node Controller): уведомляет и реагирует на сбои узла.
* Контроллер репликации (Replication Controller): поддерживает правильное количество подов для каждого объекта контроллера репликации в системе.
* Контроллер конечных точек (Endpoints Controller): заполняет объект конечных точек (Endpoints), то есть связывает сервисы (Services) и поды (Pods).
* Контроллеры учетных записей и токенов (Account & Token Controllers): создают стандартные учетные записи и токены доступа API для новых пространств имен.
* Namespace

### cloud-controller-manager
cloud-controller-manager запускает контроллеры, которые взаимодействуют с основными облачными провайдерами.

#### Nodes:
### kubelet
Агент, работающий на каждом узле в кластере. Он следит за тем, чтобы контейнеры были запущены в поде.  
Утилита kubelet принимает набор PodSpecs, и гарантирует работоспособность и исправность определённых в них контейнеров. Агент kubelet не отвечает за контейнеры, не созданные Kubernetes. Обращается в API.

### kube-proxy 
kube-proxy — сетевой прокси, работающий на каждом узле в кластере, и реализующий часть концепции сервис.  
kube-proxy конфигурирует правила сети на узлах. При помощи них разрешаются сетевые подключения к вашими подам изнутри и снаружи кластера.

### Container Runtime Interface
Среда выполнения контейнера — это программа, предназначенная для выполнения контейнеров.  
Kubernetes поддерживает несколько сред для запуска контейнеров: Docker, containerd, CRI-O, и любая реализация Kubernetes CRI (Container Runtime Interface).

#### Addons:
Дополнения используют ресурсы Kubernetes (DaemonSet, Deployment и т.д.) для расширения функциональности кластера. Поскольку дополнения охватывают весь кластер, ресурсы относятся к пространству имен kube-system

### Typical addons:

### DNS
Хотя прочие дополнения не являются строго обязательными, однако при этом у всех Kubernetes-кластеров должен быть кластерный DNS, так как многие примеры предполагают его наличие.  
Кластерный DNS — это DNS-сервер наряду с другими DNS-серверами в вашем окружении, который обновляет DNS-записи для сервисов Kubernetes.

### Dashboard
Dashboard — это универсальный веб-интерфейс для кластеров Kubernetes. С помощью этой панели, пользователи могут управлять и устранять неполадки кластера и приложений, работающих в кластере.

---

Конфигурация kubectl - это контекст (context)  
Контекст - комбинация:
1. cluster - API сервера
1. user - пользователь для подключения к кластеру
1. namespace - область видимости (не обязательно, по умолчанию
default)

Кластер (cluster) - это:
1. server - адрес kubernetes API-сервера
1. certificate-authority - корневой сертификат (которым подписан SSL-сертификат API-сервера)
1. name - имя для идентификации

Соединения keep alive между компонентами архитектуры, чтобы не открывать новые соединения.

Kuber управляет подами, а самими контейнерами управляет Container Runtime.  
В поде всегда есть родительский контейнер или pause-container, который только запускает наш целевой контейнер и получает от него код ответа.  
По умолчанию pod-ы не видят контейнеры внутри друг друга, но внутри пода общаются между собой как будто локально.  

Наиболее распространённые паттерны подов:  
* Sidecar - sidecar контейнер делит ФС через volume с основным контейнером, который просто пишет логи в stdout и забирает у него логи через filebeat, например.
* Adapter - adapter контейнер пуллит какие-то данные из основного контейнера с приложением, например, забирая метрики и пушит их на сервер (либо просто как-то преобразует в читаемый вид и выставляет наружу)
* Ambassador - обычно используется для проброски сетей до других pod

Существуют так называемые init-containers, которые запускаются до старта остальных app контейнеров и блокируют их запуск.  
Нужны для проверки зависимостей для app, подготовки данных и окружения или использования чего-то, что не хочется хранить в app.  
Их можно объединять в последовательные цепочки запуска, чтобы каждый исполнял какую-то свою подготовительную роль.  

Best practice схожий сущности описывать в одном yaml манифесте, разделяя документ `---`, а не разносить по разным файлам как обычно.  

По умолчанию в кластере создается три namespace:  
* default - для объектов у которых явно не определена принадлежность к другому namespace
* kube-system - для системных объектов Kubernetes
* kube-public - для объектов к которым нужен доступ из любой точки кластера (kubedns)

У namespace нет приоритетов, но они есть у pods.

Сервис - абстракция, которая имеет своё адресное простанство и позволяет осуществлять взаимодействие между адресными пространствами pods и балансировку.

Kubespray - ansible for kubeadm
